'use strict';

const variants$1 = require('./variants.cjs');
const core = require('@unocss/core');

const regexCache = {};
const variantBreakpoints = (matcher, { theme }) => {
  const variantEntries = Object.entries(theme.breakpoints || {}).map(([point, size], idx) => [point, size, idx]);
  for (const [point, size, idx] of variantEntries) {
    if (!regexCache[point])
      regexCache[point] = new RegExp(`^((?:[al]t-)?${point}[:-])`);
    const match = matcher.match(regexCache[point]);
    if (!match)
      continue;
    const [, pre] = match;
    const m = matcher.slice(pre.length);
    if (m === "container")
      continue;
    let direction = "min";
    let order = 1e3;
    if (pre.startsWith("lt-")) {
      direction = "max";
      order -= idx + 1;
    } else {
      order += idx + 1;
    }
    if (pre.startsWith("at-") && idx < variantEntries.length - 1) {
      return {
        matcher: m,
        parent: [`@media (min-width: ${size}) and (max-width: ${variantEntries[idx + 1][1]})`, order]
      };
    }
    return {
      matcher: m,
      parent: [`@media (${direction}-width: ${size})`, order]
    };
  }
};

const variantCombinators = [
  variants$1.variantMatcher("all", (input) => `${input} *`),
  variants$1.variantMatcher("children", (input) => `${input}>*`),
  variants$1.variantMatcher("next", (input) => `${input}+*`),
  variants$1.variantMatcher("sibling", (input) => `${input}+*`),
  variants$1.variantMatcher("siblings", (input) => `${input}~*`),
  variants$1.variantMatcher("svg", (input) => `${input} svg`)
];

const variantMotions = [
  variants$1.variantParentMatcher("motion-reduce", "@media (prefers-reduced-motion: reduce)"),
  variants$1.variantParentMatcher("motion-safe", "@media (prefers-reduced-motion: no-preference)")
];
const variantOrientations = [
  variants$1.variantParentMatcher("landscape", "@media (orientation: landscape)"),
  variants$1.variantParentMatcher("portrait", "@media (orientation: portrait)")
];
const variantPrint = variants$1.variantParentMatcher("print", "@media print");

const variantColorsMediaOrClass = (options = {}) => {
  if (options?.dark === "class") {
    return [
      variants$1.variantMatcher("dark", (input) => `.dark $$ ${input}`),
      variants$1.variantMatcher("light", (input) => `.light $$ ${input}`)
    ];
  }
  return [
    variants$1.variantParentMatcher("dark", "@media (prefers-color-scheme: dark)"),
    variants$1.variantParentMatcher("light", "@media (prefers-color-scheme: light)")
  ];
};

const variantLanguageDirections = [
  variants$1.variantMatcher("rtl", (input) => `[dir="rtl"] $$ ${input}`),
  variants$1.variantMatcher("ltr", (input) => `[dir="ltr"] $$ ${input}`)
];

const variantImportant = {
  match(matcher) {
    if (matcher.startsWith("!")) {
      return {
        matcher: matcher.slice(1),
        body: (body) => {
          body.forEach((v) => {
            if (v[1])
              v[1] += " !important";
          });
          return body;
        }
      };
    }
  }
};
const variantNegative = {
  match(matcher) {
    if (matcher.startsWith("-")) {
      return {
        matcher: matcher.slice(1),
        body: (body) => {
          body.forEach((v) => {
            if (v[0].startsWith("--un-scale") || v[1]?.toString() === "0")
              return;
            v[1] = v[1]?.toString().replace(/[0-9.]+(?:[a-z]+|%)?/, (i) => `-${i}`);
          });
          return body;
        }
      };
    }
  }
};

const PseudoClasses = Object.fromEntries([
  "any-link",
  "link",
  "visited",
  "target",
  ["open", "[open]"],
  "hover",
  "active",
  "focus-visible",
  "focus-within",
  "focus",
  "autofill",
  "enabled",
  "disabled",
  "read-only",
  "read-write",
  "placeholder-shown",
  "default",
  "checked",
  "indeterminate",
  "valid",
  "invalid",
  "in-range",
  "out-of-range",
  "required",
  "optional",
  "root",
  "empty",
  ["even-of-type", ":nth-of-type(even)"],
  ["even", ":nth-child(even)"],
  ["odd-of-type", ":nth-of-type(odd)"],
  ["odd", ":nth-child(odd)"],
  "first-of-type",
  ["first", ":first-child"],
  "last-of-type",
  ["last", ":last-child"],
  "only-child",
  "only-of-type"
].map(core.toArray));
const PseudoElements = Object.fromEntries([
  "placeholder",
  "before",
  "after",
  "first-letter",
  "first-line",
  "selection",
  "marker",
  ["file", "::file-selector-button"]
].map(core.toArray));
const PseudoClassFunctions = [
  "not",
  "is",
  "where",
  "has"
];
const PseudoElementsStr = Object.keys(PseudoElements).join("|");
const PseudoClassesStr = Object.keys(PseudoClasses).join("|");
const PseudoClassFunctionsStr = PseudoClassFunctions.join("|");
const PartClassesRE = /(part-\[(.+)]:)(.+)/;
const PseudoElementsRE = new RegExp(`^(${PseudoElementsStr})[:-]`);
const PseudoClassesRE = new RegExp(`^(${PseudoClassesStr})[:-]`);
const PseudoClassFunctionsRE = new RegExp(`^(${PseudoClassFunctionsStr})-(${PseudoClassesStr})[:-]`);
const taggedPseudoClassMatcher = (tag, parent, combinator) => {
  const re = new RegExp(`^${tag}-((?:(${PseudoClassFunctionsStr})-)?(${PseudoClassesStr}))[:-]`);
  const rawRe = new RegExp(`^${core.escapeRegExp(parent)}:`);
  return (input) => {
    const match = input.match(re);
    if (match) {
      let pseudo = PseudoClasses[match[3]] || `:${match[3]}`;
      if (match[2])
        pseudo = `:${match[2]}(${pseudo})`;
      return {
        matcher: input.slice(match[1].length + tag.length + 2),
        selector: (s) => rawRe.test(s) ? s.replace(rawRe, `${parent}${pseudo}:`) : `${parent}${pseudo}${combinator}${s}`
      };
    }
  };
};
const variantPseudoElements = (input) => {
  const match = input.match(PseudoElementsRE);
  if (match) {
    const pseudo = PseudoElements[match[1]] || `::${match[1]}`;
    return {
      matcher: input.slice(match[1].length + 1),
      selector: (s) => `${s}${pseudo}`
    };
  }
};
const variantPseudoClasses = {
  match: (input) => {
    const match = input.match(PseudoClassesRE);
    if (match) {
      const pseudo = PseudoClasses[match[1]] || `:${match[1]}`;
      return {
        matcher: input.slice(match[1].length + 1),
        selector: (s) => `${s}${pseudo}`
      };
    }
  },
  multiPass: true
};
const variantPseudoClassFunctions = {
  match: (input) => {
    const match = input.match(PseudoClassFunctionsRE);
    if (match) {
      const fn = match[1];
      const pseudo = PseudoClasses[match[2]] || `:${match[2]}`;
      return {
        matcher: input.slice(match[1].length + match[2].length + 2),
        selector: (s) => `${s}:${fn}(${pseudo})`
      };
    }
  },
  multiPass: true
};
const variantTaggedPseudoClasses = (options = {}) => {
  const attributify = !!options?.attributifyPseudo;
  return [
    {
      match: taggedPseudoClassMatcher("group", attributify ? '[group=""]' : ".group", " "),
      multiPass: true
    },
    {
      match: taggedPseudoClassMatcher("peer", attributify ? '[peer=""]' : ".peer", "~"),
      multiPass: true
    }
  ];
};
const partClasses = {
  match: (input) => {
    const match = input.match(PartClassesRE);
    if (match) {
      const part = `part(${match[2]})`;
      return {
        matcher: input.slice(match[1].length),
        selector: (s) => `${s}::${part}`
      };
    }
  },
  multiPass: true
};

const variants = (options) => [
  variantNegative,
  variantImportant,
  variantPrint,
  ...variantOrientations,
  ...variantMotions,
  variantBreakpoints,
  ...variantCombinators,
  variantPseudoClasses,
  variantPseudoClassFunctions,
  ...variantTaggedPseudoClasses(options),
  variantPseudoElements,
  partClasses,
  ...variantColorsMediaOrClass(options),
  ...variantLanguageDirections
];

exports.partClasses = partClasses;
exports.variantBreakpoints = variantBreakpoints;
exports.variantColorsMediaOrClass = variantColorsMediaOrClass;
exports.variantCombinators = variantCombinators;
exports.variantImportant = variantImportant;
exports.variantLanguageDirections = variantLanguageDirections;
exports.variantMotions = variantMotions;
exports.variantNegative = variantNegative;
exports.variantOrientations = variantOrientations;
exports.variantPrint = variantPrint;
exports.variantPseudoClassFunctions = variantPseudoClassFunctions;
exports.variantPseudoClasses = variantPseudoClasses;
exports.variantPseudoElements = variantPseudoElements;
exports.variantTaggedPseudoClasses = variantTaggedPseudoClasses;
exports.variants = variants;
