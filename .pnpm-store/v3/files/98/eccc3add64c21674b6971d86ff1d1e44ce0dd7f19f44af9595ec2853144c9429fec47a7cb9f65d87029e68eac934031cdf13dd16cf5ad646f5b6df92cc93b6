import { createValueHandler, hex2rgba } from '@unocss/core';

const directionMap = {
  "l": ["-left"],
  "r": ["-right"],
  "t": ["-top"],
  "b": ["-bottom"],
  "s": ["-inline-start"],
  "e": ["-inline-end"],
  "x": ["-left", "-right"],
  "y": ["-top", "-bottom"],
  "": [""],
  "bs": ["-block-start"],
  "be": ["-block-end"],
  "is": ["-inline-start"],
  "ie": ["-inline-end"],
  "block": ["-block-start", "-block-end"],
  "inline": ["-inline-start", "-inline-end"]
};
const insetMap = {
  ...directionMap,
  s: ["-inset-inline-start"],
  e: ["-inset-inline-end"],
  bs: ["-inset-block-start"],
  be: ["-inset-block-end"],
  is: ["-inset-inline-start"],
  ie: ["-inset-inline-end"],
  block: ["-inset-block-start", "-inset-block-end"],
  inline: ["-inset-inline-start", "-inset-inline-end"]
};
const cornerMap = {
  "l": ["-top-left", "-bottom-left"],
  "r": ["-top-right", "-bottom-right"],
  "t": ["-top-left", "-top-right"],
  "b": ["-bottom-left", "-bottom-right"],
  "tl": ["-top-left"],
  "lt": ["-top-left"],
  "tr": ["-top-right"],
  "rt": ["-top-right"],
  "bl": ["-bottom-left"],
  "lb": ["-bottom-left"],
  "br": ["-bottom-right"],
  "rb": ["-bottom-right"],
  "": [""],
  "bs": ["-start-start", "-start-end"],
  "be": ["-end-start", "-end-end"],
  "is": ["-end-start", "-start-start"],
  "ie": ["-start-end", "-end-end"],
  "bs-is": ["-start-start"],
  "is-bs": ["-start-start"],
  "bs-ie": ["-start-end"],
  "ie-bs": ["-start-end"],
  "be-is": ["-end-start"],
  "is-be": ["-end-start"],
  "be-ie": ["-end-end"],
  "ie-be": ["-end-end"]
};
const xyzMap = {
  "x": ["-x"],
  "y": ["-y"],
  "z": ["-z"],
  "": ["-x", "-y"]
};
const basePositionMap = [
  "top",
  "top center",
  "top left",
  "top right",
  "bottom",
  "bottom center",
  "bottom left",
  "bottom right",
  "left",
  "left center",
  "left top",
  "left bottom",
  "right",
  "right center",
  "right top",
  "right bottom",
  "center",
  "center top",
  "center bottom",
  "center left",
  "center right",
  "center center"
];
const positionMap = Object.assign({}, ...basePositionMap.map((p) => ({ [p.replace(/ /, "-")]: p })), ...basePositionMap.map((p) => ({ [p.replace(/\b(\w)\w+/g, "$1").replace(/ /, "")]: p })));

const cssProps = [
  "color",
  "border-color",
  "background-color",
  "flex-grow",
  "flex",
  "flex-shrink",
  "caret-color",
  "font",
  "gap",
  "opacity",
  "visibility",
  "z-index",
  "font-weight",
  "zoom",
  "text-shadow",
  "transform",
  "box-shadow",
  "backround-position",
  "left",
  "right",
  "top",
  "bottom",
  "object-position",
  "max-height",
  "min-height",
  "max-width",
  "min-width",
  "height",
  "width",
  "border-width",
  "margin",
  "padding",
  "outline-width",
  "outline-offset",
  "font-size",
  "line-height",
  "text-indent",
  "vertical-align",
  "border-spacing",
  "letter-spacing",
  "word-spacing",
  "stroke",
  "filter",
  "backdrop-filter",
  "fill",
  "mask",
  "mask-size",
  "mask-border",
  "clip-path",
  "clip"
];
const numberWithUnitRE = /^(-?[0-9.]+)(px|pt|pc|rem|em|%|vh|vw|in|cm|mm|ex|ch|vmin|vmax)?$/i;
const numberRE = /^(-?[0-9.]+)$/i;
const unitOnlyRE = /^(px)$/i;
function round(n) {
  return n.toFixed(10).replace(/\.0+$/, "").replace(/(\.\d+?)0+$/, "$1");
}
function numberWithUnit(str) {
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = parseFloat(n);
  if (unit && !Number.isNaN(num))
    return `${round(num)}${unit}`;
}
function auto(str) {
  if (str === "auto" || str === "a")
    return "auto";
}
function rem(str) {
  if (str.match(unitOnlyRE))
    return `1${str}`;
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = parseFloat(n);
  if (!Number.isNaN(num))
    return unit ? `${round(num)}${unit}` : `${round(num / 4)}rem`;
}
function px(str) {
  if (str.match(unitOnlyRE))
    return `1${str}`;
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = parseFloat(n);
  if (!Number.isNaN(num))
    return unit ? `${round(num)}${unit}` : `${round(num)}px`;
}
function number(str) {
  if (!numberRE.test(str))
    return;
  const num = parseFloat(str);
  if (!Number.isNaN(num))
    return round(num);
}
function percent(str) {
  if (str.endsWith("%"))
    str = str.slice(0, -1);
  const num = parseFloat(str);
  if (!Number.isNaN(num))
    return `${round(num / 100)}`;
}
function fraction(str) {
  if (str === "full")
    return "100%";
  const [left, right] = str.split("/");
  const num = parseFloat(left) / parseFloat(right);
  if (!Number.isNaN(num))
    return `${round(num * 100)}%`;
}
function bracket(str) {
  if (str && str[0] === "[" && str[str.length - 1] === "]") {
    return str.slice(1, -1).replace(/(url\(.*?\))/g, (v) => v.replace(/_/g, "\\_")).replace(/(?<!\\)_/g, " ").replace(/calc\((.*)/g, (v) => {
      return v.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ");
    });
  }
}
function cssvar(str) {
  if (str.startsWith("$"))
    return `var(--${str.slice(1)})`;
}
function time(str) {
  const match = str.match(/^(-?[0-9.]+)(s|ms)?$/i);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = parseFloat(n);
  if (!Number.isNaN(num))
    return unit ? `${round(num)}${unit}` : `${round(num)}ms`;
}
function degree(str) {
  const match = str.match(/^(-?[0-9.]+)(deg|rad|grad|turn)?$/i);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = parseFloat(n);
  if (!Number.isNaN(num))
    return unit ? `${round(num)}${unit}` : `${round(num)}deg`;
}
function global(str) {
  if (["inherit", "initial", "revert", "unset"].includes(str))
    return str;
}
function properties(str) {
  for (const prop of str.split(",")) {
    if (!cssProps.includes(prop))
      return;
  }
  return str;
}

const valueHandlers = {
  __proto__: null,
  numberWithUnit: numberWithUnit,
  auto: auto,
  rem: rem,
  px: px,
  number: number,
  percent: percent,
  fraction: fraction,
  bracket: bracket,
  cssvar: cssvar,
  time: time,
  degree: degree,
  global: global,
  properties: properties
};

const handler = createValueHandler(valueHandlers);
const h = handler;

const directionSize = (propertyPrefix) => ([_, direction, size]) => {
  const v = handler.bracket.cssvar.auto.fraction.rem(size);
  if (v !== void 0)
    return directionMap[direction].map((i) => [`${propertyPrefix}${i}`, v]);
};
const getThemeColor = (theme, colors) => theme.colors?.[colors.join("-").replace(/(-[a-z])/g, (n) => n.slice(1).toUpperCase())];
const parseColor = (body, theme) => {
  const [main, opacity] = body.split(/(?:\/|:)/);
  const colors = main.replace(/([a-z])([0-9])/g, "$1-$2").split(/-/g);
  const [name] = colors;
  if (!name)
    return;
  let color;
  const bracket = handler.bracket(main);
  const bracketOrMain = bracket || main;
  if (bracketOrMain.startsWith("#"))
    color = bracketOrMain.slice(1);
  else if (bracketOrMain.startsWith("hex-"))
    color = bracketOrMain.slice(4);
  else if (main.startsWith("$"))
    color = handler.cssvar(main);
  color = color || bracket;
  let no = "DEFAULT";
  if (!color) {
    let colorData;
    const [scale] = colors.slice(-1);
    if (scale.match(/^\d+$/)) {
      no = scale;
      colorData = getThemeColor(theme, colors.slice(0, -1));
    } else {
      colorData = getThemeColor(theme, colors);
      if (!colorData) {
        [, no = no] = colors;
        colorData = getThemeColor(theme, [name]);
      }
    }
    if (typeof colorData === "string")
      color = colorData;
    else if (no && colorData)
      color = colorData[no];
  }
  const rgba = hex2rgba(color);
  const alpha = opacity ? opacity[0] === "[" ? handler.bracket.percent(opacity) : parseFloat(opacity) / 100 : rgba?.[3];
  const hasAlpha = alpha != null && !Number.isNaN(alpha);
  if (rgba) {
    if (hasAlpha) {
      rgba[3] = typeof alpha === "string" && !alpha.includes("%") ? parseFloat(alpha) : alpha;
    } else {
      rgba.splice(3);
    }
  }
  return {
    opacity,
    name,
    no,
    color,
    rgba,
    alpha: hasAlpha ? alpha : void 0
  };
};
const colorResolver = (property, varName) => ([, body], { theme }) => {
  const data = parseColor(body, theme);
  if (!data)
    return;
  const { alpha, opacity, color, rgba } = data;
  if (!color)
    return;
  if (rgba) {
    if (alpha != null) {
      return {
        [property]: `rgba(${rgba.join(",")})`
      };
    } else {
      return {
        [`--un-${varName}-opacity`]: (opacity && handler.cssvar(opacity)) ?? 1,
        [property]: `rgba(${rgba.join(",")},var(--un-${varName}-opacity))`
      };
    }
  } else {
    return {
      [property]: color.replace("%alpha", `${alpha || 1}`)
    };
  }
};

export { cornerMap as a, directionSize as b, colorResolver as c, directionMap as d, positionMap as e, h as f, handler as h, insetMap as i, parseColor as p, valueHandlers as v, xyzMap as x };
